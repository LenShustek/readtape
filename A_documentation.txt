READTAPE: A program to recover data from old computer magnetic tapes 

OVERVIEW 

This software,still in development, analyzes the analog signal from a 
multi-track digital magnetic tape to reconstruct the original digital 
data. The motivation for starting with the analog data is to be able to 
recover data that has degraded to the point where conventional tape 
drives won't read it. 

The input to the program is a sequence of periodic samples of the analog 
voltage from all channels of the read head as the tape is moving. It is a 
CSV (comma-separated-value) text file with a series of floating point 
numbers. The first number on each line is a timestamp in seconds, and 
the next N values on the lines are the voltages from the N tracks. 

I am currently using a Qualstar 1052 tape drive with either a 9-track or 
7-track head installed. The drive manual is here: 
http://bitsavers.trailing-edge.com/pdf/qualstar/500150B_1052serviceMan.pdf.  
The analog samples are taken from the output of the second-stage 
amplifiers in the front end, which is pin 1 of Ux02A shown in the 
schematic on page 91. The drive is put in diagnostic read mode, which 
causes the tape to move past the heads without needing to send any 
commands over the computer interface. 

The analog to digital conversion is done with a Saleae 16-channel logic 
analyzer (https://www.saleae.com/), which does 12-bit digitization (4096 
possible values) of single-ended signals from -10V to +10V. Having 
bipolar inputs is important, because the output of the second operational 
amplifier is typically +-2V to +-6V. For degraded areas of the tapes it 
goes lower, but automatic gain control in the software allows it to 
decode signals that go as low as +-0.1V. 

I've used different sample rates depending on the density and drive speed, 
but I try to get about 20 samples per cycle. For 800 BPI NRZI at 50 IPS, 
the Saleae 781 Khz rate works well. The analyzer supports rates as high 
as 50 Mhz. 

The logic analyzer streams the data to a computer over a type 3.0 USB 
port. The data is stored in the computer's virtual memory, so the time 
and space limits are set by the memory+disk speed and size. Recording 
for many minutes to create files that take dozens of gigabytes hasn't 
been a problem. Files are saved in Saleae's proprietary format, but
some of all of the file can exported to a CSV file.

USING THE PROGRAM 

This is a command-line (non-GUI) program written in standard C. I've 
been testing on a Windows PC, but it should work in other environments 
too. 

The program is invoked as follows: 

readtape <options> <basefilename>
   the input file is <basefilename>.csv
   the optional decoding parameter file is <basefilename>.parms
     (or NRZI.parms or PE.parms)
   the output files will be in the created directory <basefilename>\
   the log file will be put in that directory as <basefilename>.log
Options:
 -ntrks=n  sets the number of tracks; default is 9
 -order=   set input data order for bits 0..ntrks-2 and P
           0=MSB; default is 01234567P for 9 trks
 -pe       do PE decoding; sets bpi=1600, ips=50
 -nrzi     do NRZI decoding; sets bpi=800, ips=50
 -gcr      do GCR decoding; sets bpi=6250, ips=25
 -bpi=n    override density in bits/inch
 -ips=n    override speed in inches/sec
 -even     even parity for 7-track NRZI BCD tapes
 -skip=n   skip the first n samples
 -tap      create one SIMH .tap file from the data
 -m        try multiple ways to decode a block
 -l        create a log file
 -v        verbose mode (all info)
 -t        terse mode (only bad block info)
 -q        quiet mode (only say "ok" or "bad")
 -f        take file list from <basefilename>.txt

Decoding is controlled by a set of parameters that adjust the 
algorithms. No one set of parameters will work for all tapes or even all 
blocks of one tape. You can specify multiple sets of parameters, and the 
program will try as many as necessary to get a perfect decoding of a 
block, or pick the one that generates the minimum number of errors. 

Each set of records between tapemarks is stored as separate file. If it
detects IBM standard labels, it uses those to name the files and doesn't
write the labels themselves. In -tap mode, it creates one tape image
file in SIMH format, http://simh.trailing-edge.com/docs/simh_magtape.pdf.

The parameter sets that control the decoding algorithms can be read in 
from a file that is specific to the tape data being decoded 
(<basefilename>.parms), or from a generic file for that encoding type 
(NRZI.parms, etc.). If no parameter file is provided, the program uses 
built-in defaults. 

This program is still a work in progress, so the parameter sets continue 
to evolve. The current set of parameters are these: 

   int active;             // 1 means this is an active parameter set
   int clk_window;         // how many bit times to average for clock rate; 0 means maybe use exponential averaging
   float clk_alpha;        // weighting for current data in the clock rate exponential weighted average; 0 means use constant
   int agc_window;         // how many peaks to look back for the min peak to set AGC; 0 means maybe use exponential averaging
   float agc_alpha;        // weighting for current data in the AGC exponential weight average; 0 means no AGC
   float min_peak;         // the minimum height of a peak in volts
   float clk_factor;       // PE: how much of a half-bit period to wait for a clock transition
   float pulse_adj;        // how much of the previous pulse's deviation to adjust this pulse by, 0 to 1
   float pkww_bitfrac;     // what fraction of the bit spacing the window width is
   char id[4];             // "PRM", to make sure the sructure initialization isn't screwed up

The format of a parameter file is as follows:

//  comments
readtape <additional command line options>
parms active, clk_window,  clk_alpha, agc_window, agc_alpha, min_peak, clk_factor, pulse_adj, pkww_bitfrac, id
 {1,   0,     0.2,      5,    0.0,    0.0,   1.50,    0.4,   0.7, "PRM" }
 {1,   3,     0.0,      5,    0.0,    0.0,   1.40,    0.0,   0.7, "PRM" }
...

The leading 1 indicates an active parameter set, and the trailing "PRM" 
is for error checking. The numbers in between are the parameters in the 
order given by the "parms" line of the file. 

If there is a now-obsolete parameter name in the file that the program 
no longer knows about, it is ignored with a warning. If a parameter name 
that the program expects is missing, the value from the first built-in 
parmset is used. This scheme allows us to add and remove parameters 
types in the program without completely invalidating existing .parm 
files. 

THE ALGORITHMS

This is a work-in-progress, so the algorithms will probably will have 
changed by the time you read these descriptions. 

Peak Detection

As the tape moves past the head, a flux transition on any track creates 
a voltage peak, either positive or negative, in accordance with 
Faraday's Law, V = dB/dT. The amplitude of the voltage depends on many 
things: tape speed, bit density, head design, track alignment, and the 
exact sequence of flux transitions. 

We record the analog signal after a differential amplifier, a low-pass 
filter, and a differential to single-ended amplifier in the drive 
electronics. The signal is amazingly clean, with little noise or jitter 
that isn't attributable to the data on the tape. 

The first version of software peak detection used a hill-climbing 
algorithm to detect a local minimum or maximum. We kept track of whether 
we were going uphill or downhill, and recorded a peak when the direction 
changed by a non-trivial amount. The actual time of the peak was 
calculated by interpolating the times of samples that were close the the 
peak. 

The problem was that, especially when combined with the AGC algorithm 
described later, it was subject to false positives when the signal is 
small or when there are small variations. It would work when the 
parameters were carefully tweaked, but it was not robust. 

The second version of peak detection, which seems to work better, uses a 
moving window shape detector. We keep track of the last N samples for 
each track, of course using a circular buffer with head and tail 
pointers so the data doesn't have to be moved. As each new data point is 
entered, we look to see if the maximum (minimum) sample is much higher 
(lower) than the oldest and newest values, and record a peak if so. We 
then become blind to peaks until that peak exits the window. 

The number of samples in the window is set dynamically based on the 
expected bit rate and a settable parameter. The amount by which a peak 
has to exceed the oldest and newest values is also parametrized and 
varies with the current AGC. The time of the peak is interpolated based 
on the previous and next sample values, so that if two or three values 
close to the peak are averaged. 

Compensation for "pulse shifting", which depends on the sequence and 
proximity of flux transitions, is done by computing the difference 
between the possible expected position of the pulse (which depends on 
the kind of encoding used) and the observed position. A parameter 
controls what fraction of that distance should be used to adjust the 
time of the peak before using it in the decoding algorithm. 

AGC: Automatic Gain Control

To compensate for differences in signal amplitude between tapes, between 
blocks, and between bits, we keep track of the average or expected peak 
heights for each track separately. The calculation produces an AGC value 
between 0.1 (for big signals) and 20 (for low signals). We change it by 
one of two algorithms: 

- exponential averaging: the new value is alpha * current + (1-alpha) * 
old average. This provide a kind of low-pass filter so that it changes 
slowly. 

- recent minimum: the value is based on the minimum peak of the 
last N peaks we've seen. (Again, implemented with a circular buffer with 
head and tail pointers so data doesn't have to be moved.) This works 
better for some tapes where there are isolated very small peaks.

The AGC value is used for the following two calculations: 

- choosing how high (low) a voltage must be to be considered a peak 

- adjusting how close adjacent peaks need to be for their times to be 
averaged 

High values of AGC let us detect peaks that are as small as 0.1V during 
dropouts on a particular track, yet still be able to ignore noise at 
other times when the signal is strong. 

Clock Recovery

...TBD..  window and exponential averaging...


PE Decoding Techniques

PE (phase encoding) has a negative flux transition for a 0-bit and a 
positive flux transition for a 1-bit. At the midpoint between bits, 
there is an optional flux transition if needed to prepare for the 
correct next bit flux transition. This is sometimes described as 
"Manchester" encoding. 

...TBD... 

NRZI Decoding Techniques

NRZI (non return to zero inverted) encoding has a flux transition of 
either direction for a 1-bit, and no transition for a 0-bit. Recovering 
the clock depends on there being frequent 1-bits at at least one track. 
My algorithm for NRZI decoding tolerates some track-to-track skew by 
working as follows: 

- Average the time that multiple tracks have "nearby" transitions, and 
use that as the assumed bit time. 

- The time between successive bit times establishes the data frequency, 
whose change over time is smoothed either by averaging over a fixed 
number of bits or by exponential weighting. 

- The time of any particular track's transition is compared to the 
expected bit time, and a settable fraction (50% seems to work well) of 
the deviation is used to adjust the transition time. (That tweak was 
added to compensate for data-dependent peak-shifting, but it should help 
for skew too.) 

- The decision about whether a track lacked a transition at a bit time 
isn't made until about halfway (0.6 seems to work well) between bit 
times. 

The bottom line is that it can probably tolerate track skew up to about 
25% of the inter-bit time, which seems to work well for most tapes. 

If we need to insert large track de-skewing data delays, they could be 
set using using a "master skew tape". Alternatively, we can could do 
statistical analysis of the transitions before trying to decode. For 
example: preprocess many blocks of a random data tape and look for the 
differences in timing between the tracks whose block data starts with a 
1-bit. (That's a fuzzy description; would need to work on the details.) 

One aspect of head alignment can't be fixed in software and is critical: 
we need enough S/N so that the AGC algorithm can see the transitions, 
and minimal leakage between adjacent tracks. 

....more to come....

L. Shustek, 10 April 2018

