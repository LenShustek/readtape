READTAPE: A program to recover data from old computer magnetic tapes 

OVERVIEW 

This software being developed analyzes the analog signal from a 
multi-track digital magnetic tape to reconstruct the original digital 
data. The motivation for starting with the analog data is to be able to 
recover data that has degraded to the point where conventional tape 
drives won't read it. 

The input to the program is a series of periodic samples of the analog 
voltage from all channels of the read head as the tape is moving. It is a 
CSV (comma-separated-value) text file with a series of floating point 
numbers. The first number on each line is a timestamp in seconds, and 
the next N values on the lines are the voltages from the N tracks. 

I am current using a Qualstar 1052 tape drive, with either a 9-track or 
7-track head installed. The drive manual is here: 
http://bitsavers.trailing-edge.com/pdf/qualstar/500150B_1052serviceMan.pdf.  
The analog samples are taken from the output of the second-stage 
amplifiers in the front end, which is pin 1 of Ux02A shown in the 
schematic on page 91. The drive is put in diagnostic read mode, which 
causes the tape to move past the heads without needing to send any 
commands over the computer interface. 

The analog to digital conversion is done with a Saleae 16-channel logic 
analyzer (https://www.saleae.com/), which does 12-bit digitization (4096 
possible values) of single-ended signals from -10V to +10V. Having 
bipolar inputs is important, because the output of the differential 
amplifier is typically +-2V to +-6V. For degraded areas of the tapes it 
goes lower, but automatic gain control in the software allows it to 
decode signals that go as low as +-0.1V. 

I've used different sample rates depending on the density and drive speed, 
but I try to get about 20 samples per cycle. For 800 BPI NRZI at 50 IPS, 
the Saleae 781 Khz rate works well. The analyzer supports rates as high 
as 50 Mhz. 

The logic analyzer streams the data to a computer over a type 3.0 USB 
port. The data is stored in the computer's virtual memory, so the time 
and space limits are set by the memory+disk speed and size. Recording 
for many minutes to create files that take dozens of gigabytes hasn't 
been a problem. Files are saved in Saleae's proprietary format, but
some of all of the file can exported to a CSV file.

THE PROGRAM 

This is a command-line (non-GUI) program written in standard C. I've 
been testing on a Windows PC, but it should work in other environments 
too. 

The program is invoked as follows: 

readtape <options> <basefilename>
   the input file is <basefilename>.csv
   the optional decoding parameter file is <basefilename>.parms
     (or NRZI.parms or PE.parms)
   the output files will be in the created directory <basefilename>\
   the log file will be put in that directory as <basefilename>.log
Options:
 -ntrks=n  sets the number of tracks; default is 9
 -order=   set input data order for bits 0..ntrks-2 and P
           0=MSB; default is 01234567P for 9 trks
 -pe       do PE decoding; sets bpi=1600, ips=50
 -nrzi     do NRZI decoding; sets bpi=800, ips=50
 -gcr      do GCR decoding; sets bpi=6250, ips=25
 -bpi=n    override density in bits/inch
 -ips=n    override speed in inches/sec
 -even     even parity for 7-track NRZI BCD tapes
 -skip=n   skip the first n samples
 -tap      create one SIMH .tap file from the data
 -m        try multiple ways to decode a block
 -l        create a log file
 -v        verbose mode (all info)
 -t        terse mode (only bad block info)
 -q        quiet mode (only say "ok" or "bad")
 -f        take file list from <basefilename>.txt

Decoding is controlled by a set of parameters that adjust the 
algorithms. No one set of parameters will work for all tapes or even all 
blocks of one tape. You can specify multiple sets of parameters, and the 
program will try as many as necessary to get a perfect decoding of a 
block, or pick the one that generates the minimum number of errors. 

Each set of records between tapemarks is stored as separate file. If it
detects IBM standard labels, it uses those to name the files but doesn't
write the labels themselves. In -tap mode, it creates one tape image
file in SIMH format, http://simh.trailing-edge.com/docs/simh_magtape.pdf.

The parameter sets that control the decoding algorithms can be read in 
from a file that is specific to the tape data being decoded 
(<basefilename>.parms), or from a generic file for that encoding type 
(NRZI.parms, etc.). If no parameter file is given, the program uses 
built-in defaults. 

This program is still a work in progress, so the parameter sets continue 
to evolve. The current set of parameters are these: 

   int active;             // 1 means this is an active parameter set
   int clk_window;         // how many bit times to average for clock rate; 0 means maybe use exponential averaging
   float clk_alpha;        // weighting for current data in the clock rate exponential weighted average; 0 means use constant
   int agc_window;         // how many peaks to look back for the min peak to set AGC; 0 means maybe use exponential averaging
   float agc_alpha;        // weighting for current data in the AGC exponential weight average; 0 means no AGC
   float min_peak;         // the minimum height of a peak in volts
   float clk_factor;       // PE: how much of a half-bit period to wait for a clock transition
   float pulse_adj;        // how much of the previous pulse's deviation to adjust this pulse by, 0 to 1
   float pkww_bitfrac;     // what fraction of the bit spacing the window width is
   char id[4];             // "PRM", to make sure the sructure initialization isn't screwed up

The format of the parameter file is as follows:

//  comments
readtape <additional command line options>
parms active, clk_window,  clk_alpha, agc_window, agc_alpha, min_peak, clk_factor, pulse_adj, pkww_bitfrac, id
 {1,   0,     0.2,      5,    0.0,    0.0,   1.50,    0.4,   0.7, "PRM" }
 {1,   3,     0.0,      5,    0.0,    0.0,   1.40,    0.0,   0.7, "PRM" }
...

The leading 1 indicates an active parameter set, and the trailing "PRM" 
is for error checking. The numbers in between are the parameters in the 
order given by the "parms" line of the file. 

If there is a now-obsolete parm name in the file that the program no 
longer knows about, it is ignored with a warning. If a parm name that 
the program expects is missing, the value from the first built-in 
parmset is used. That scheme allows us to add and remove parm types in 
the program without invalidating existing .parm files. 


PE DECODING TECHNIQUES

PE (phase encoding) has a negative flux transition for a 0-bit and a 
positive flux transition for a 1-bit. At the midpoint between bits, 
there is an optional flux transition if needed to prepare for the 
correct next bit flux transition. 

...description TBD... 

NRZI DECODING TECHNIQUES

NRZI (non return to zero inverted) encoding has a flux transition of 
either direction for a 1-bit, and no transition for a 0-bit. Recovering 
the clock depends on there being frequent 1-bits at at least one track. 
My algorithm for NRZI decoding tolerates some track-to-track skew by 
working as follows: 

- Average the time that multiple tracks have "nearby" transitions, and 
use that as the assumed bit time. 

- The time between successive bit times establishes the data frequency, 
whose change over time is smoothed either by averaging over a fixed 
number of bits or by exponential weighting. 

- The time of any particular track's transition is compared to the 
expected bit time, and a settable fraction (50% seems to work well) of 
the deviation is used to adjust the transition time. (That tweak was 
added to compensate for data-dependent peak-shifting, but it should help 
for skew too.) 

- The decision about whether a track lacked a transition at a bit time 
isn't made until about halfway (0.6 seems to work well) between bit 
times. 

The bottom line is that it can probably tolerate track skew up to about 
25% of the inter-bit time, which seems to work well for most tapes. 

If we need to insert large track de-skewing data delays, they could be 
set using using a "master skew tape". Alternatively, we can could do 
statistical analysis of the transitions before trying to decode. For 
example: preprocess many blocks of a random data tape and look for the 
differences in timing between the tracks whose block data starts with a 
1-bit. (That's a fuzzy description; would need to work on the details.) 

One aspect of head alignment can't be fixed in software and is critical: 
we need enough S/N so that the AGC algorithm can see the transitions, 
and minimal leakage between adjacent tracks. 

....more to come....

L. Shustek, 9 April 2018

